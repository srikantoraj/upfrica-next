//@FilePath: /upfrica-next/src/contexts/AuthContext.js
"use client";

import { createContext, useContext, useEffect, useState } from "react";
import axiosInstance from "@/lib/axiosInstance";
import {
  getFromStorage as getItem,
  saveToStorage as setItem,
  removeFromStorage as removeItem,
} from "@/app/utils/storage";

const AuthContext = createContext();
const ME_ENDPOINT = "/api/users/me/"; // ‚úÖ backend now returns { ...user, onboarding }

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);   // stores full /users/me payload (includes onboarding)
  const [token, setToken] = useState(null);
  const [hydrated, setHydrated] = useState(false);

  // ‚úÖ Load token & user on mount and hydrate from API
  useEffect(() => {
    const savedToken = getItem("token");
    const savedUser = getItem("user");

    if (savedToken) {
      setToken(savedToken);
      axiosInstance.defaults.headers.common["Authorization"] = `Token ${savedToken}`;
    }
    if (savedUser) {
      setUser(savedUser);
    }

    const hydrate = async () => {
      if (savedToken) {
        try {
          const res = await axiosInstance.get(ME_ENDPOINT, { cache: "no-store" });
          setUser(res.data);
          setItem("user", res.data);
        } catch (err) {
          console.error("‚ùå Failed to hydrate user:", err);
          logout(); // Graceful logout if token/user invalid
        }
      }
      setHydrated(true);
    };

console.log("[Auth] /me payload:", data);
console.log(
  "[Auth] account_type raw:", data?.account_type,
  "| typeof:", typeof data?.account_type,
  "| isArray:", Array.isArray(data?.account_type)
);

    hydrate();
  }, []);



  useEffect(() => {
    // optional debug
    // console.log("üß™ AuthContext hydrated =", hydrated, "üîë token =", token, "üë§ user =", user);
  }, [hydrated, token, user]);

  /**
   * login({ user, token, onboarding }) ‚Äî pass the raw login payload in.
   * Returns the onboarding block so the caller can redirect immediately.
   */
  const login = async (loginPayload) => {
    const authToken = loginPayload?.token;
    if (!authToken) throw new Error("Missing token");

    setToken(authToken);
    setItem("token", authToken);
    axiosInstance.defaults.headers.common["Authorization"] = `Token ${authToken}`;

    try {
      // Single source of truth: refresh from /users/me (includes onboarding)
      const res = await axiosInstance.get(ME_ENDPOINT, { cache: "no-store" });
      setUser(res.data);
      setItem("user", res.data);
      setHydrated(true);
      return res.data?.onboarding || loginPayload?.onboarding || null;
    } catch (err) {
      console.error("‚ùå Failed to fetch user after login:", err);
      // Fallback to login payload to avoid dead-end
      const fallback = {
        ...(loginPayload?.user || {}),
        onboarding: loginPayload?.onboarding || null,
      };
      setUser(fallback);
      setItem("user", fallback);
      setHydrated(true);
      return fallback.onboarding;
    }
  };

  const logout = () => {
    setUser(null);
    setToken(null);
    removeItem("user");
    removeItem("token");
    delete axiosInstance.defaults.headers.common["Authorization"];
  };

  const refreshUser = async () => {
    const authToken = token || getItem("token");
    if (!authToken) return;

    try {
      axiosInstance.defaults.headers.common["Authorization"] = `Token ${authToken}`;
      const res = await axiosInstance.get(ME_ENDPOINT, { cache: "no-store" });
      setUser(res.data);
      setItem("user", res.data);
      return res.data;
    } catch (err) {
      console.error("‚ùå Failed to refresh user:", err);
    }
  };

  // ‚úÖ Full readiness
  const fullyReady = hydrated && !!token && !!user;

  // Role helpers
  const roles = user?.account_type || [];
  const isBuyer = roles.includes("buyer");
  const isSeller = roles.includes("seller_private") || roles.includes("seller_business");
  const isAgent = roles.includes("agent");
  const isAffiliate = roles.includes("affiliate");

  // Server-driven onboarding status (preferred)
  const onboarding = user?.onboarding || null;
  const requiresOnboarding = onboarding ? !onboarding.complete : ((isSeller || isAgent) && !user?.onboarded);

  return (
    <AuthContext.Provider
      value={{
        user,
        setUser,
        token,
        setToken,
        hydrated,
        fullyReady,
        login,
        logout,
        refreshUser,
        // roles
        isBuyer,
        isSeller,
        isAgent,
        isAffiliate,
        // onboarding
        onboarding,
        requiresOnboarding,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error("‚ùå useAuth must be used within an <AuthProvider>");
  }
  return context;
}